// Generated by LiveScript 1.4.0
'use strict';
var curry, apply, applyTo, immediate, slice$ = [].slice;
curry = require('./curry');
exports.id = function(a){
  return a;
};
exports.curry = curry;
exports.compose = function(){
  var fns;
  fns = slice$.call(arguments);
  return function(){
    var i, result;
    i = fns.length;
    result = apply(fns[--i], arguments);
    while (i--) {
      result = fns[i](result);
    }
    return result;
  };
};
apply = exports.apply = curry(function(f, xs){
  switch (xs.length) {
  case 0:
    return f();
  case 1:
    return f(xs[0]);
  case 2:
    return f(xs[0], xs[1]);
  case 3:
    return f(xs[0], xs[1], xs[2]);
  case 4:
    return f(xs[0], xs[1], xs[2], xs[3]);
  case 5:
    return f(xs[0], xs[1], xs[2], xs[3], xs[4]);
  case 6:
    return f(xs[0], xs[1], xs[2], xs[3], xs[4], xs[5]);
  case 7:
    return f(xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6]);
  case 8:
    return f(xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6], xs[7]);
  case 9:
    return f(xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6], xs[7], xs[8]);
  default:
    return f.apply(void 8, xs);
  }
});
applyTo = exports.applyTo = curry(function(ctx, f, xs){
  switch (xs.length) {
  case 0:
    return f.call(ctx);
  case 1:
    return f.call(ctx, xs[0]);
  case 2:
    return f.call(ctx, xs[0], xs[1]);
  case 3:
    return f.call(ctx, xs[0], xs[1], xs[2]);
  case 4:
    return f.call(ctx, xs[0], xs[1], xs[2], xs[3]);
  case 5:
    return f.call(ctx, xs[0], xs[1], xs[2], xs[3], xs[4]);
  case 6:
    return f.call(ctx, xs[0], xs[1], xs[2], xs[3], xs[4], xs[5]);
  case 7:
    return f.call(ctx, xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6]);
  case 8:
    return f.call(ctx, xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6], xs[7]);
  case 9:
    return f.call(ctx, xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6], xs[7], xs[8]);
  default:
    return f.apply(ctx, xs);
  }
});
exports.applyNew = curry(function(F, xs){
  var Surrogate;
  switch (xs.length) {
  case 0:
    return new F;
  case 1:
    return new F(xs[0]);
  case 2:
    return new F(xs[0], xs[1]);
  case 3:
    return new F(xs[0], xs[1], xs[2]);
  case 4:
    return new F(xs[0], xs[1], xs[2], xs[3]);
  case 5:
    return new F(xs[0], xs[1], xs[2], xs[3], xs[4]);
  case 6:
    return new F(xs[0], xs[1], xs[2], xs[3], xs[4], xs[5]);
  case 7:
    return new F(xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6]);
  case 8:
    return new F(xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6], xs[7]);
  case 9:
    return new F(xs[0], xs[1], xs[2], xs[3], xs[4], xs[5], xs[6], xs[7], xs[8]);
  default:
    Surrogate = function(){
      F.apply(this, xs);
    };
    Surrogate.prototype = F.prototype;
    return new Surrogate;
  }
});
exports.flip = function(f){
  return function(){
    var xs, i, len, args;
    xs = slice$.call(arguments);
    i = 0;
    len = xs.length;
    args = new Array(len);
    while (len !== 0) {
      args[--len] = xs[i++];
    }
    args;
    return apply(f, args);
  };
};
exports.delay = curry(function(msec, fn){
  return setTimeout(fn, msec);
});
exports.interval = curry(function(msec, fn){
  var i, iv;
  i = 0;
  return iv = setInterval(function(){
    if (fn(i++) === false) {
      clearInterval(iv);
    }
  }, msec);
});
immediate = exports.immediate = function(fn){
  if (typeof setImmediate === 'function') {
    setImmediate(fn);
  } else if ((typeof process != 'undefined' && process !== null) && process.nextTick) {
    process.nextTick(fn);
  } else {
    setTimeout(fn, 0);
  }
  return fn;
};
exports.tryCatch = function(fn, cb){
  var res, e, err;
  try {
    res = fn();
  } catch (e$) {
    e = e$;
    err = e instanceof Error
      ? e
      : new Error(e);
  }
  if (typeof cb === 'function') {
    cb(err, res);
  }
  return err || res;
};
exports.once = function(fn){
  var name;
  name = fn.name || 'Function';
  return function(){
    if (!fn) {
      throw new Error(name + " was already called.");
    }
    apply(fn, arguments);
    fn = void 8;
  };
};
exports.chain = function(){
  var i$, funcs, cb, i, callback, link, err;
  funcs = 0 < (i$ = arguments.length - 1) ? slice$.call(arguments, 0, i$) : (i$ = 0, []), cb = arguments[i$];
  i = 0;
  callback = function(args){
    return immediate(function(){
      return apply(cb, args);
    });
  };
  link = function(pos){
    return function(err){
      var args;
      args = slice$.call(arguments, 1);
      if (pos !== i) {
        return callback([new Error("callback[" + (pos + 1) + "] is called twice!")]);
      }
      if (err) {
        return callback([err].concat(slice$.call(args)));
      }
      i += 1;
      immediate(function(){
        var next, argLen, err;
        if (i === funcs.length) {
          return callback([void 8].concat(slice$.call(args)));
        }
        next = funcs[i];
        argLen = next.length;
        try {
          return apply(next, args.slice(0, argLen - 1).concat(link(i)));
        } catch (e$) {
          err = e$;
          return callback([err]);
        }
      });
    };
  };
  try {
    funcs[i](link(i));
  } catch (e$) {
    err = e$;
    callback([err]);
  }
};