// Generated by LiveScript 1.4.0
'use strict';
var curry, ObjToString, RX_ISUUID, PRIMITIVE_TYPES, EXTENDED_TYPES, ALL_TYPE_CHECKS, ALL_TYPE_CHECKS_REV, slice$ = [].slice;
curry = require('./curry');
ObjToString = Object.prototype.toString;
RX_ISUUID = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i;
PRIMITIVE_TYPES = ['Number', 'String', 'Boolean', 'Function', 'Promise', 'Array', 'Set', 'Map', 'Arguments', 'Object', 'Date', 'Error', 'RegExp', 'Symbol', 'Null', 'Undefined'];
EXTENDED_TYPES = ['PlainObject', 'UUID', 'Integer', 'Defined'];
ALL_TYPE_CHECKS = PRIMITIVE_TYPES.concat(EXTENDED_TYPES);
ALL_TYPE_CHECKS_REV = ALL_TYPE_CHECKS.concat().reverse();
exports.getType = function(it){
  var i$, ref$, len$, type;
  for (i$ = 0, len$ = (ref$ = PRIMITIVE_TYPES).length; i$ < len$; ++i$) {
    type = ref$[i$];
    if (exports["is" + type](it)) {
      return type;
    }
  }
};
exports.getExtendedType = function(it){
  var i$, ref$, len$, type;
  for (i$ = 0, len$ = (ref$ = ALL_TYPE_CHECKS_REV).length; i$ < len$; ++i$) {
    type = ref$[i$];
    if (exports["is" + type](it)) {
      return type;
    }
  }
};
exports.isNumber = function(it){
  return typeof it === 'number' && !isNaN(it) && isFinite(it);
};
exports.isString = function(it){
  return typeof it === 'string';
};
exports.isBoolean = function(it){
  return typeof it === 'boolean';
};
exports.isBool = exports.isBoolean;
exports.isFunction = function(it){
  return typeof it === 'function';
};
exports.isPromise = function(it){
  return typeof it === 'object' && (it.constructor && deepEq$(it.constructor.name, 'Promise', '==='));
};
exports.isArray = function(it){
  return Array.isArray(it);
};
exports.isSet = function(it){
  return it instanceof Set;
};
exports.isObject = function(it){
  return it !== null && deepEq$(typeof it, 'object', '===') && !(it instanceof Error) && !(it instanceof Date) && !(it instanceof Set) && !(it instanceof Map) && !(it instanceof RegExp) && !Array.isArray(it);
};
exports.isMap = function(it){
  return it instanceof Map;
};
exports.isArguments = function(it){
  return ObjToString.call(it) === '[object Arguments]';
};
exports.isDate = function(it){
  return it instanceof Date;
};
exports.isError = function(it){
  return it instanceof Error;
};
exports.isRegExp = function(it){
  return it instanceof RegExp;
};
exports.isSymbol = function(it){
  return typeof it === 'symbol';
};
exports.isNull = function(it){
  return it === null;
};
exports.isUndefined = function(it){
  return typeof it === 'undefined';
};
exports.isPlainObject = function(it){
  return it instanceof Object && Object.getPrototypeOf(it) === Object.getPrototypeOf({});
};
exports.isDefined = function(it){
  return typeof it !== 'undefined' && it !== null;
};
exports.isUUID = function(it){
  return typeof it === 'string' && RX_ISUUID.test(it);
};
exports.isInteger = function(it){
  return !isNaN(it) && it % 1 === 0;
};
exports.isInt = exports.isInteger;
exports.inRange = curry(function(from, to, it){
  return exports.isNumber(it) && from <= it && to >= it;
});
ALL_TYPE_CHECKS.forEach(function(type){
  return exports["is" + type + "Array"] = function(it){
    return Array.isArray(it) && it.length > 0 && it.every(exports["is" + type]);
  };
});
exports.isBoolArray = exports.isBooleanArray;
exports.isIntArray = exports.isIntegerArray;
exports.oneOf = function(){
  var xs;
  xs = slice$.call(arguments);
  return function(a){
    var i$, ref$, len$, x;
    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (x === a) {
        return true;
      }
    }
    return false;
  };
};
function deepEq$(x, y, type){
  var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,
      has = function (obj, key) { return hasOwnProperty.call(obj, key); };
  var first = true;
  return eq(x, y, []);
  function eq(a, b, stack) {
    var className, length, size, result, alength, blength, r, key, ref, sizeB;
    if (a == null || b == null) { return a === b; }
    if (a.__placeholder__ || b.__placeholder__) { return true; }
    if (a === b) { return a !== 0 || 1 / a == 1 / b; }
    className = toString.call(a);
    if (toString.call(b) != className) { return false; }
    switch (className) {
      case '[object String]': return a == String(b);
      case '[object Number]':
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        return +a == +b;
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') { return false; }
    length = stack.length;
    while (length--) { if (stack[length] == a) { return true; } }
    stack.push(a);
    size = 0;
    result = true;
    if (className == '[object Array]') {
      alength = a.length;
      blength = b.length;
      if (first) {
        switch (type) {
        case '===': result = alength === blength; break;
        case '<==': result = alength <= blength; break;
        case '<<=': result = alength < blength; break;
        }
        size = alength;
        first = false;
      } else {
        result = alength === blength;
        size = alength;
      }
      if (result) {
        while (size--) {
          if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }
        }
      }
    } else {
      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {
        return false;
      }
      for (key in a) {
        if (has(a, key)) {
          size++;
          if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }
        }
      }
      if (result) {
        sizeB = 0;
        for (key in b) {
          if (has(b, key)) { ++sizeB; }
        }
        if (first) {
          if (type === '<<=') {
            result = size < sizeB;
          } else if (type === '<==') {
            result = size <= sizeB
          } else {
            result = size === sizeB;
          }
        } else {
          first = false;
          result = size === sizeB;
        }
      }
    }
    stack.pop();
    return result;
  }
}